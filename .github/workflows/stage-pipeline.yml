name: Stage Pipeline - Integration Tests & Deploy

on:
  workflow_run:
    workflows: ["Development CI Pipeline"]
    types:
      - completed
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      force_recreate_minikube:
        description: 'Force recreate Minikube cluster'
        required: false
        default: false
        type: boolean

jobs:
  stage-deploy:
    runs-on: self-hosted
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}

    env:
      COMPOSE_FILE: ./compose.yml
      BUILD_SCRIPT: ./build-images-minikube.ps1
      DEPLOY_SCRIPT: ./deploy-individual-services.bat
      NAMESPACE: ecommerce-microservices

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up JDK 11
        uses: actions/setup-java@v3
        with:
          java-version: '11'
          distribution: 'temurin'

      - name: Cache Maven dependencies
        uses: actions/cache@v3
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2

      - name: Check if Minikube exists
        id: check_minikube
        shell: powershell
        continue-on-error: true
        run: |
          Write-Host "Checking Minikube status..."
          
          $minikubeRunning = $false
          
          try {
            $status = minikube status 2>&1
            Write-Host "Minikube status output:"
            Write-Host $status
            
            if ($status -match "Running" -or $status -match "host: Running") {
              Write-Host "Minikube is running"
              $minikubeRunning = $true
            }
          } catch {
            Write-Host "Could not get Minikube status: $_"
          }
          
          if ($minikubeRunning) {
            echo "minikube_exists=true" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "Minikube is not running or does not exist"
            echo "minikube_exists=false" >> $env:GITHUB_OUTPUT
          }

      - name: Check deployed services in namespace
        id: check_deployment
        shell: powershell
        run: |
          Write-Host "Checking if services are already deployed in namespace $env:NAMESPACE ..."
          
          $deployed = $false
          $ns = kubectl get namespace $env:NAMESPACE --ignore-not-found=true 2>$null
          if ($ns) {
            $pods = kubectl get pods -n $env:NAMESPACE --no-headers 2>$null
            $svcapigw = kubectl get svc api-gateway-service -n $env:NAMESPACE --ignore-not-found=true 2>$null
            if ($pods -and $svcapigw) {
              $deployed = $true
            }
          }
          if ($deployed) {
            Write-Host "Namespace and services detected. Reusing existing deployment."
            echo "services_deployed=true" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "No existing deployment found. Will build and deploy."
            echo "services_deployed=false" >> $env:GITHUB_OUTPUT
          }

      - name: Clean existing Minikube namespace and images (forced)
        if: github.event.inputs.force_recreate_minikube == 'true'
        shell: powershell
        run: |
          Write-Host "Cleaning namespace and existing resources..."
          
          kubectl delete namespace $env:NAMESPACE --ignore-not-found=true
          
          do {
            $ns = kubectl get namespace $env:NAMESPACE --ignore-not-found=true 2>$null
            if (-not $ns) { break }
            Write-Host "Waiting for namespace to be deleted..."
            Start-Sleep -Seconds 5
          } while ($true)
          
          Write-Host "Removing previous images from Minikube..."
          minikube image rm ecommerce/user-service:latest --ignore-not-found
          minikube image rm ecommerce/order-service:latest --ignore-not-found  
          minikube image rm ecommerce/product-service:latest --ignore-not-found
          minikube image rm ecommerce/payment-service:latest --ignore-not-found
          minikube image rm ecommerce/shipping-service:latest --ignore-not-found
          minikube image rm ecommerce/api-gateway:latest --ignore-not-found
          minikube image rm ecommerce/service-discovery:latest --ignore-not-found
          minikube image rm ecommerce/cloud-config:latest --ignore-not-found
          
          Write-Host "Cleanup completed!"

      - name: Create or recreate Minikube
        if: steps.check_minikube.outputs.minikube_exists == 'false' || github.event.inputs.force_recreate_minikube == 'true'
        shell: powershell
        run: |
          if ("${{ github.event.inputs.force_recreate_minikube }}" -eq "true") {
            Write-Host "Recreating Minikube as requested..."
            minikube delete --purge
          }
          
          Write-Host "Creating new Minikube cluster..."
          minikube start --memory=12974 --cpus=4 --driver=docker
          
          $status = minikube status
          if ($status -match "Running") {
            Write-Host "Minikube created and running correctly"
          } else {
            Write-Host "Error creating Minikube"
            exit 1
          }

      - name: Build images directly in Minikube
        if: steps.check_deployment.outputs.services_deployed != 'true'
        shell: powershell
        run: |
          Write-Host "Building Docker images directly inside Minikube..."
          powershell -ExecutionPolicy Bypass -File $env:BUILD_SCRIPT
          
          Write-Host "Verifying images in Minikube Docker daemon:"
          & minikube docker-env --shell powershell | Invoke-Expression
          docker images | Select-String -Pattern "service|gateway|proxy|cloud|product|order|payment|shipping|favourite"

      - name: Deploy to Kubernetes
        if: steps.check_deployment.outputs.services_deployed != 'true'
        shell: powershell
        run: |
          Write-Host "Deploying services to Kubernetes..."
          
          kubectl create namespace $env:NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
          
          if (Test-Path $env:DEPLOY_SCRIPT) {
            Write-Host "Using deployment script: $env:DEPLOY_SCRIPT"
            & $env:DEPLOY_SCRIPT
          } else {
            Write-Host "Deploy script not found: $env:DEPLOY_SCRIPT"
            Write-Host "Available files in current directory:"
            Get-ChildItem -Name "*.bat"
            exit 1
          }

      - name: Wait for pods to be ready
        shell: powershell
        run: |
          Write-Host "Waiting for all pods to be ready..."
          kubectl wait --for=condition=ready pod --all -n $env:NAMESPACE --timeout=600s
          
          Write-Host "Final pod status:"
          kubectl get pods -n $env:NAMESPACE
          
          Write-Host "Available services:"
          kubectl get svc -n $env:NAMESPACE

      - name: Run Integration Tests (against deployed services)
        shell: powershell
        run: |
          Write-Host "Running integration tests for microservices communication..."
          
          $services = @("user-service", "order-service", "product-service", "payment-service", "shipping-service")
          
          foreach ($service in $services) {
            if (Test-Path "$service/src/test/java") {
              Write-Host "Running integration tests for $service..."
              cd $service
              mvn test `-Dtest=*IntegrationTest `-Dspring.profiles.active=test `-Dmaven.test.failure.ignore=true
              cd ..
            }
          }
          
          Write-Host "Integration tests completed!"

      - name: Generate Stage Report
        if: always()
        shell: powershell
        run: |
          Write-Host "Stage Pipeline Report:"
          Write-Host "=================================="
          Write-Host "Integration Tests: Executed"
          $minikubeStatus = "${{ steps.check_minikube.outputs.minikube_exists }}"
          if ($minikubeStatus -eq "true") {
            Write-Host "Minikube: Cleaned and updated"
          } else {
            Write-Host "Minikube: Created from scratch"
          }
          Write-Host "Docker Images: Built and loaded"
          Write-Host "Kubernetes Deploy: Completed"
          Write-Host "Pods Status: ${{ job.status }}"
          Write-Host ""
          Write-Host "Stage environment ready for manual testing!"
          Write-Host "Access services using:"
          Write-Host "minikube service api-gateway-service -n ecommerce-microservices"

  e2e-tests:
    runs-on: self-hosted
    needs: stage-deploy
    if: success()

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js for Newman
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: e2e-tests/package.json

      - name: Install E2E Dependencies
        working-directory: e2e-tests
        run: |
          Write-Output "Installing E2E dependencies..."
          npm ci --legacy-peer-deps

      - name: Wait for Services to be Ready
        working-directory: e2e-tests
        run: |
          Write-Output "Waiting for services to be ready for E2E testing..."
          node wait-for-services.js

      - name: Run E2E Tests (minikube)
        working-directory: e2e-tests
        run: |
          Write-Output "Running End-to-End tests on Minikube..."
          npm run test:e2e:minikube

      - name: Generate E2E Test Summary
        if: always()
        working-directory: e2e-tests
        run: |
          if (Test-Path "results/newman-report.json") {
            Write-Output "E2E Test Results Summary:"
            $report = Get-Content "results/newman-report.json" | ConvertFrom-Json
            $stats = $report.run.stats
            
            Write-Output "  Total Requests: $($stats.requests.total)"
            Write-Output "  Passed: $($stats.requests.total - $stats.requests.failed)"
            Write-Output "  Failed: $($stats.requests.failed)"
            Write-Output "  Average Response Time: $([Math]::Round($stats.requests.average))ms"
            Write-Output "  Total Response Time: $($stats.requests.totalTime)ms"
            
            if ($stats.requests.failed -gt 0) {
              Write-Output "Some E2E tests failed!"
              $report.run.executions | Where-Object { $_.response.code -ge 400 } | ForEach-Object {
                Write-Output "  Failed: $($_.item.name) - Status: $($_.response.code)"
              }
              exit 1
            } else {
              Write-Output "All E2E tests passed successfully!"
            }
          } else {
            Write-Output "E2E test report not found"
            exit 1
          }

      - name: Upload E2E Test Reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-test-reports
          path: |
            e2e-tests/results/newman-report.json
            e2e-tests/results/newman-report.html
          retention-days: 30
